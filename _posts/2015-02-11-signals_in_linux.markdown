---
layout: post
title:  "SIGNALS IN LINUX"
date: 2015-02-11 14:00 +0800
categories:  Linux
---

linux上写代码，经常遇到一些SIG开头的错误提示，每次遇到都很DT的找寻好久。在家闲来无事看了Linux System Programing的Signals部分，感觉书中写的很好，于是乎总结一下就有了本文。

### 信号（signals）

信号是提供异步事件处理机制的软件中断，是进程间通信的主要方式。
不只是事件发生是异步的，信号处理也是异步的。

### 信号的生命周期

* 产生
* 内核存储
* 内核处理信号 

### 信号处理方式

* 忽略（ignore）
* 处理 （handle）
handle又包括调用默认action和自定义action

### 信号标示符

头文件：`#include<signal.h>`

SIGNAL实质是一个正数，没有零，零代表 null signal

下边是linux中一些信号的描述和默认action:

| Signal | Description | Default action |
| ------ | ----------- | -------------- |
| SIGABRT | Sent by abort() | Terminate with core dump |
| SIGALRM | Sent by alarm() | Terminate |
| SIGBUS | Hardware or alignment error | Terminate with core dump |
| SIGCHLD | Child has terminated | Ignored |
| SIGCONT | Process has continued after being stopped | Ignored |
| SIGFPE | Arithmetic exception | Terminate with core dump |
| SIGHUP | Process’s controlling terminal was closed (most frequently, the user logged out) | Terminate |
| SIGILL | Process tried to execute an illegal instruction | Terminate with core dump |
| SIGINT | User generated the interrupt character (Ctrl-C) | Terminate |
| SIGIO | Asynchronous I/O event | Terminate^a |
| SIGKILL | Uncatchable process termination | Terminate |
| SIGPIPE | Process wrote to a pipe but there are no readers | Terminate |
| SIGPROF | Profiling timer expired | Terminate |
| SIGPWR | Power failure | Terminate |
| SIGQUIT | User generated the quit character (Ctrl-\) | Terminate with core dump |
| SIGSEGV | Memory access violation | Terminate with core dump |
| SIGSTKFLT | Coprocessor stack fault | Terminate^b |
| SIGSTOP | Suspends execution of the process | Stop |
| SIGSYS | Process tried to execute an invalid system call | Terminate with core dump |
| SIGTERM | Catchable process termination | Terminate |
| SIGTRAP | Break point encountered | Terminate with core dump |
| SIGTSTP | User generated the suspend character (Ctrl-Z) | Stop |
| SIGTTIN | Background process read from controlling terminal | Stop |
| SIGTTOU | Background process wrote to controlling terminal | Stop |
| SIGURG | Urgent I/O pending | Ignored |
| SIGUSR1 | Process-defined signal | Terminate |
| SIGUSR2 | Process-defined signal | Terminate |
| SIGVTALRM | Generated by setitimer()  when called with the ITIMER_VIRTUAL flag | Terminate |
| SIGWINCH | Size of controlling terminal window changed | Ignored |
| SIGXCPU | Processor resource limits were exceeded | Terminate with core dump |
| SIGXFSZ | File resource limits were exceeded | Terminate with core dump |

a: The behavior on other Unix systems, such as BSD, is to ignore this signal.

b: The Linux kernel no longer generates this signal; it remains only for backward compatibility.


这里边有31个信号标示符，看着就头大，总结几个常见的吧，然后其他再遇到的继续查 Linux System Programming。

1. SIGINT    Crtl+C

2. SIGKILL    process is forcefully terminated

3. SIGABT    about()发出，接着进程终止并产生一个core file（这是什么？） 。在linux中，assert()之类的断言会调用about() 。一般这个错误经常遇到，主要是内存分配和释放错误，比如一个指针free了两次，然后assert时候就挂掉了。SIGABRT是中止一个程序，它可以被捕捉，但不能被阻塞。处理函数返回后，所有打开的文件描述符将会被关闭，流也会被flush。程序会结束，有可能的话还会core dump。 当程序调用abort(3)时，该进程会向自己发送SIGABRT信号。所以，SIGABRT一般用于信号中一些关键的处理，assert失败时也会使用它。不应该去捕捉SIGSEGV和SIGABRT信号，如果收到这种信号，说明进程处于一个不确定的状态，很可能会直接挂起。

4. SIGSEGV This signal, whose name derives from segmentation violation, is sent to a process when it attempts an invalid memory access. This includes accessing unmapped memory, reading from memory that is not read-enabled, executing code in memory that is not execute-enabled, or writing to memory that is not write-enabled. Processes may catch and handle this signal, but the default action is to terminate the process and generate a core dump. 这个是经常遇到的非法访问内存错误，C++的内存操作还是要认真学习积累经验啊。

5. SIGBUS 这个我没遇到过，不过有人说address alignment可能会导致SIGBUS，先放到这里，以后遇到再来总结。

